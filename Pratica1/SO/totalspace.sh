#!/bin/bash 
function findFiles() {

	#FILES
	for file in $(ls -p "$1" | grep -v '\/$')	
	do
		conCat $1 $file
		file=$path
    	######################### CANT ACCESS FILE IN DIRECTORY (stat fails)#########################
		if ! stat "$file" >/dev/null 2>/dev/null 1>/dev/null;then
			if [[ -z "$currentDir" ]]; then
				argError=1 #Makes it so we remember that the First folder called is gonna be NA
				continue
			fi
			error=1
			continue
		fi
		#############################################################################################

    	######################### -d #########################
		if [[ ! -z "$d" ]]; then	#Check is d was declared
			thisDate=$(stat -c  %X "$file")	#%X -> Time of last access
			if [[ $thisDate > $d ]]; then	#If thisdate comes after the declared date, ignore the file
				continue
			fi
		fi
    	######################################################

    	######################### -n #########################
	echo $file
    	if [[ ! -z "$n" && ! $file =~ "^$n" ]]; then #If n has been declared and the file doesnt match the regex expression specified, ignore the file
				continue
		fi
    	######################################################


		value=$(stat --printf="%s" "$file")	#Get the value of the file


    		######################### -l #########################
		if [[  ! -z "$l" ]]; then	#Check if l has been declared
			if [[ -z "$currentDir" ]]; then	#Note that $1 wont be assigned to the currentDir variable
				allArgSizes+=($value)	#Add the fille to the allArgSizes array which contains all files of the first directory specified
				continue
			fi
			allSizes+=($value)	#Add the file to the allSizes array (contains every single file in the current directory)
			######################################################
		else
		    ######################### -L #########################

		    if [[ ! -z "$L" ]]; then	
		    	duplicate=0

		    	for element in "${bigFiles[@]}" 	#Check if we already have that file in the array (important for when we specify the same directory twice)
		    	do
		    		if [[ $element == "$value $file" ]];then
		    			duplicate=1
		    			continue
		    		fi
		    	done

		    	if [[ $duplicate == 1 ]]; then
		    		continue
		    	fi

			    bigFiles+=("$value $file")
			    bigFiles=( $( printf "%s\n" "${bigFiles[@]}" | sort -n -r ) )
			    continue
		    fi	
		    ######################################################

			argSize=$(( $argSize + $value ))	#Add to the first specified directory size
			dirSize=$(( $dirSize + $value ))	#Add to the current directory size
		fi
	done
	
	#DIRECTORIES
	for dir in $(ls -p "$1" | grep '\/$')	
	do
		dir=${dir::-1}	#Due to the way the code is strucutured we need to remove the / generated by the ls -p
		conCat "$1" "$dir"
			
        local currentDir="$path"	#Store the current directory so we can search it≈õ subdirectories
        local dirSize=0	#Store total directory size
        local error=0	

       	######################### -l #########################
		if [[  ! -z "$l" ]]; then
			local allSizes=()
		fi
		######################################################

		######################### CANT ACCESS DIRECTORY #########################
		if ! test -r $currentDir;then	#Normally ls only fails when the folder is non-readable
			directories+=([$currentDir]="NA")
			argError=1	#Makes it so we remember that the First folder called is gonna be NA
			continue
		fi
		#################################################################################

		findFiles "$currentDir"	#Recursivity

		######################### -L #########################
		if [[ ! -z "$L" ]];then
			continue
		fi
		#####################################################

    	######################### -l #########################
		if [[  ! -z "$l" ]]; then
			getBiggestFiles "${allSizes[@]}" "$dirSize"
			dirSize=$thisSize
		fi
		######################################################

		subDirSearch $currentDir
		dirSize=$(( $dirSize + $thisDirSize ))	

		######################### CANT ACCESS FILE OR SUBDIRECTORY IN DIRECTORY #########################
		if [[ $error == 1 ]];then
			directories+=([$currentDir]="NA")
			argError=1	#Makes it so we remember that the First folder called is gonna be NA
			error=0
			continue
		fi
		#################################################################################

		directories+=([$currentDir]=${dirSize})

	done

	return 0
}

function subDirSearch(){
	thisDirSize=0
    ######################### SUBDIRECTORIES ########################################################		
	for subDir in $(ls --group-directories-first "$1")	#Iterate over every subdirectory
	do
		subDir="$1/$subDir"
		if [[ -d "$subDir" ]]; then
			thisValue=${directories[$subDir]}	#Total size value of the subDirectory

			######################### CANT ACCESS SUBDIRECTORY OR SUBDIRECTORY HAS SIZE NA #########################
			if ! test -r $subDir || [[ $thisValue = "NA" ]];then
				error=1
				continue
			fi
			#################################################################################

			if [[  ! -z "$thisValue" ]]; then	#If subDir is in the directories associative array
				thisDirSize=$(( $thisDirSize + $thisValue ))	
			fi									
		fi
	done
}

function conCat(){
	if [[ "${1: -1}" != '/' ]];then	#Make it so we always get baseDirectory/FILE, and never baseDirectoryFILE (which would break)
		path="$1/$2"
	else
		path="$1$2"
	fi	
}

function getBiggestFiles(){
	thisAllSizes=( $( printf "%s\n" "$@" | sort -n -r) )
    thisSize=0

	for (( i=0; i<"$l" && i<"${#thisAllSizes[@]}"; i++ ))
	do
		thisSize=$(( $thisSize + ${thisAllSizes[$i]} ))
	done
}

function usage(){
    echo
    echo "Usage: totalspace.sh [OPTION]... [DIRECTORY(s)]"
    echo "At least ONE directory must be passed"
    echo "Options:"
    echo "		-a: Sort alphabetically"
    echo "		-r: Sort in reverse order"
    echo "		-d [date]: Maximum file access date"
    echo "		-l [int]: Number of the biggest files to be consider in each directory"
    echo "		-L [int]: Number of the biggest files to be consider in all directories"
    echo "		-n [regex expression]: Consider only files that match the specified regex expression"
    echo "		-h: Show usage info."
}


IFS=$'\n'
sortType="-rn"

#GETOPTS###############################################################################################
while getopts ":l:d:L:n:arh" opt; do
  case $opt in
	n)	
		n=$OPTARG
		;;
	l)
		declare -a allArgSizes 
		l=$OPTARG

		if ! [[ $l =~ ^[0-9]+$ ]] ; then
   			echo "Error!"
   			usage
   			exit 1
		fi
		;;
	d)
		d=$OPTARG
		if [[ $d =~ ^[0-9]+$ ]] ; then
   			echo "Error!"
   			usage
   			exit 1
		fi

		d=$(date -d $d +%s) 
		if [[ $? == 1 ]] ; then
   			echo "Error!"
   			usage
   			exit 1
		fi
		;;
	L)
		L=$OPTARG
		if ! [[ $L =~ ^[0-9]+$ ]] ; then
   			echo "Error!"
   			usage
   			exit 1
		fi
		;;

	a)
		a=1
		sortType="-k 2"
		;;
	r)
		r=1
		sortType="-n"
		;;
	h)
		usage
		exit 0
		;;
	*)
		usage
		exit 0
		;;
	esac
done

if [[ ! -z "$l" && ! -z "$L" ]]; then
	echo "Error! Only -l OR -L can be activated at a time"
	usage 
	exit 1
fi

if [[ ! -z "$a" && ! -z "$r" ]]; then
	sortType="-rk 2"
fi

shift $((OPTIND-1))	#Make it so the Options dont get read as directories (shifts the OPTIND to the end of the options)



#GETOPTS###############################################################################################

if [[ $# == 0 ]];then	#Check if any directory is passed
	echo "Error!"
	usage
	exit 1
fi

if [[ ! -z "$L" ]];then
	declare -a bigFiles
fi

#Main:
{
for arg in $@
	do 
		if [[ -d "$arg" ]] ; then	#Make sure were not trying to read any of the getopts/files			
			
			######################### CANT ACCESS DIRECTORY #########################
			if ! test -r $arg;then
				echo "NA $arg"
				continue
			fi
			#################################################################################
			
			declare -A directories=() 	#Creates an associative array		

			argSize=0
			argError=0
			

			findFiles "$arg"

			######################### l #########################			
			if [[  ! -z "$l" ]]; then
				getBiggestFiles "${allArgSizes[@]}" $argSize 
				argSize=$thisSize
				subDirSearch $arg
				argSize=$(( $argSize + $thisDirSize ))	
       		##################################################################################################
			fi
				
			######################### NO L #########################			
			if [[ -z "$L" ]];then
					if [[ $argError == 1 ]];then
						directories+=([$arg]="NA")		
					else
						directories+=([$arg]=${argSize})		
					fi
			        for i in "${!directories[@]}"
				    do
				    	echo "${directories[$i]} ${i}"
				    done
			fi
			#################################################################################

		else	#Caso o diretorio nao exista:
			echo "Directory: $arg not found or is a file"
			continue
		fi
	done
	
	######################### L #########################			

	if [[ ! -z "$L" ]];then
		for (( i=0; i<$L && i<${#bigFiles[@]}; i++ ))
		do
			echo ${bigFiles[$i]}
		done

	fi
	} | sort $sortType
 	#################################################################################


exit 0
